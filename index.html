<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>纸片动画与俄罗斯方块</title>
    <style>
        body{margin:0;padding:0;overflow:hidden;background:#1a1a1a}
        #canvas{width:100%;height:100%;display:block}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        let mouseX = 0, mouseY = 0, papers = [], meteors = [], tetrisLeft, tetrisTop;
        const paperCount = 100, tetrisWidth = 10, tetrisHeight = 20, blockSize = 30, 
              colors = ['#c6e2ff','#ffcccb','#ffebcc','#e8f5e9','#ffebee','#ffc8dd'],
              shapes = [[1,1,1,1],[[1,1],[1,1]],[[0,1,0],[1,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,1]],[[1,0,0],[1,1,1]],[[0,0,1],[1,1,1]]];
        const meteorInterval = 30000; 
        let lastMeteorTime = 0; 

        class Paper{
            constructor(){
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 20 + 10;
                this.vx = 0, this.vy = Math.random() * 2 + 1;
                this.speedFactor = Math.random() * 0.5 + 0.5;
                this.angle = Math.random() * 360;
                this.alpha = Math.random() * 0.3 + 0.2;
                this.color = `hsla(${Math.random() * 360},70%,60%,${this.alpha})`
            }
            update(){
                const time = Date.now() * 0.001;
                const windX = Math.sin(time) * 2 + (Math.random() - 0.5) * 3;
                const windY = Math.sin(time * 1.5) * 1 + (Math.random() - 0.5) * 2;
                
                this.vx += windX * this.speedFactor * 0.1;
                this.vy += windY * this.speedFactor * 0.1;
                
                const dx = this.x - mouseX, dy = this.y - mouseY, distance = Math.sqrt(dx*dx + dy*dy);
                if(distance < 200){
                    const force = 1 - distance/200;
                    this.vx += dx * force * 0.005;
                    this.vy += dy * force * 0.005;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                if(this.x < 0 || this.x > canvas.width){
                    this.vx *= -0.8;
                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                }
                if(this.y < 0 || this.y > canvas.height){
                    this.vy *= -0.8;
                    this.y = Math.max(0, Math.min(canvas.height, this.y));
                }
            }
            draw(){
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        class Meteor{
            constructor(){
                this.x = Math.random() * canvas.width;
                this.y = -Math.random() * canvas.height;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 4 + 2;
                this.alpha = 0.5 + Math.random() * 0.5;
                this.active = true;
                this.tail = [];
                this.tailLength = Math.floor(Math.random() * 5) + 3;
            }
            update(){
                this.y += this.speed;
                this.tail.push({x:this.x, y:this.y, alpha:this.alpha * 0.6});
                if(this.tail.length > this.tailLength) this.tail.shift();
                
                if(this.y + this.size > canvas.height) this.active = false;
                this.alpha = Math.max(0, this.alpha - 0.005);
            }
            draw(){
                ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 90%, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                this.tail.forEach(({x, y, alpha}) => {
                    ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 90%, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, this.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        for(let i = 0; i < paperCount; i++) papers.push(new Paper());

        class Tetris{
            constructor(){
                this.matrix = Array(tetrisHeight).fill().map(_ => Array(tetrisWidth).fill(0));
                this.currentShape = null;
                this.currentX = 0, this.currentY = 0;
                this.score = 0, this.interval = 1000;
                this.gameOver = false;
                this.fallInterval = null;
                this.nextShapeIndex = Math.floor(Math.random() * shapes.length);
                this.currentColorIndex = Math.floor(Math.random() * colors.length);
                this.newShape();
                this.startGame();
            }
            newShape(){
                this.currentShape = shapes[this.nextShapeIndex];
                this.currentX = Math.floor(tetrisWidth / 2) - Math.ceil(this.currentShape[0].length / 2);
                this.currentY = 0;
                this.nextShapeIndex = Math.floor(Math.random() * shapes.length);
                this.currentColorIndex = Math.floor(Math.random() * colors.length);
                
                let collision = false;
                for(let y = 0; y < this.currentShape.length; y++){
                    for(let x = 0; x < this.currentShape[y].length; x++){
                        if(this.currentShape[y][x]){
                            if(this.currentY + y >= tetrisHeight || this.currentX + x < 0 || this.currentX + x >= tetrisWidth || this.matrix[this.currentY + y]?.[this.currentX + x]){
                                collision = true;
                                break;
                            }
                        }
                    }
                    if(collision) break;
                }
                if(collision) this.gameOver = true;
            }
            startGame(){
                if(!this.gameOver){
                    this.fallInterval = setInterval(() => this.moveDown(), this.interval);
                }
            }
            moveDown(){
                if(!this.checkCollision(0, 1)){
                    this.currentY++;
                }else{
                    this.mergeShape();
                    this.clearLines();
                    this.newShape();
                }
                if(this.gameOver){
                    clearInterval(this.fallInterval);
                    saveScore(this.score);
                }
            }
            moveLeft(){
                if(!this.checkCollision(-1, 0)) this.currentX--;
            }
            moveRight(){
                if(!this.checkCollision(1, 0)) this.currentX++;
            }
            rotate(){
                const rotated = this.currentShape[0].map((_, i) => 
                    this.currentShape.map(row => row[i])
                ).reverse();
                if(!this.checkCollision(0, 0, rotated)) this.currentShape = rotated;
            }
            checkCollision(dx = 0, dy = 0, shape = this.currentShape){
                for(let y = 0; y < shape.length; y++){
                    for(let x = 0; x < shape[y].length; x++){
                        if(shape[y][x]){
                            const newX = this.currentX + x + dx;
                            const newY = this.currentY + y + dy;
                            if(newX < 0 || newX >= tetrisWidth || newY < 0 || newY >= tetrisHeight || this.matrix[newY]?.[newX]){
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            mergeShape(){
                for(let y = 0; y < this.currentShape.length; y++){
                    for(let x = 0; x < this.currentShape[y].length; x++){
                        if(this.currentShape[y][x]){
                            this.matrix[this.currentY + y][this.currentX + x] = this.currentColorIndex;
                        }
                    }
                }
            }
            clearLines(){
                let cleared = 0;
                for(let y = tetrisHeight - 1; y >= 0; y--){
                    if(this.matrix[y].every(cell => cell !== 0)){
                        this.matrix.splice(y, 1);
                        this.matrix.unshift(Array(tetrisWidth).fill(0));
                        cleared++;
                    }
                }
                this.score += cleared * 10;
            }
            draw(){
                ctx.fillStyle = '#2d2d2d';
                ctx.fillRect(tetrisLeft - 5, tetrisTop - 5, tetrisWidth * blockSize + 10, tetrisHeight * blockSize + 10);
                
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                for(let x = 0; x <= tetrisWidth; x++){
                    ctx.beginPath();
                    ctx.moveTo(tetrisLeft + x * blockSize, tetrisTop);
                    ctx.lineTo(tetrisLeft + x * blockSize, tetrisTop + tetrisHeight * blockSize);
                    ctx.stroke();
                }
                for(let y = 0; y <= tetrisHeight; y++){
                    ctx.beginPath();
                    ctx.moveTo(tetrisLeft, tetrisTop + y * blockSize);
                    ctx.lineTo(tetrisLeft + tetrisWidth * blockSize, tetrisTop + y * blockSize);
                    ctx.stroke();
                }

                for(let y = 0; y < this.currentShape.length; y++){
                    for(let x = 0; x < this.currentShape[y].length; x++){
                        if(this.currentShape[y][x]){
                            ctx.fillStyle = colors[this.currentColorIndex];
                            ctx.fillRect(tetrisLeft + (this.currentX + x) * blockSize, 
                                        tetrisTop + (this.currentY + y) * blockSize, 
                                        blockSize - 2, blockSize - 2);
                        }
                    }
                }
                
                for(let y = 0; y < tetrisHeight; y++){
                    for(let x = 0; x < tetrisWidth; x++){
                        if(this.matrix[y][x]){
                            ctx.fillStyle = colors[this.matrix[y][x]];
                            ctx.fillRect(tetrisLeft + x * blockSize, 
                                        tetrisTop + y * blockSize, 
                                        blockSize - 2, blockSize - 2);
                        }
                    }
                }
                
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.fillText(`Score: ${this.score}`, tetrisLeft + tetrisWidth * blockSize + 20, tetrisTop + 40);

                if(this.gameOver){
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Game Over!', canvas.width/2, canvas.height/2);
                    ctx.fillText('按回车重新开始', canvas.width/2, canvas.height/2 + 60);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '20px Arial';
                    ctx.fillText('排行榜', tetrisLeft + tetrisWidth * blockSize + 20, tetrisTop + 80);
                    const scores = loadScores();
                    scores.forEach((s, i) => {
                        ctx.fillText(`${i+1}.${s.name}: ${s.score}`, 
                                    tetrisLeft + tetrisWidth * blockSize + 20, 
                                    tetrisTop + 120 + i * 30);
                    });
                }
            }
            restart(){
                clearInterval(this.fallInterval);
                this.matrix = Array(tetrisHeight).fill().map(_ => Array(tetrisWidth).fill(0));
                this.currentShape = null;
                this.currentX = 0, this.currentY = 0;
                this.score = 0;
                this.gameOver = false;
                this.nextShapeIndex = Math.floor(Math.random() * shapes.length);
                this.currentColorIndex = Math.floor(Math.random() * colors.length);
                this.newShape();
                this.startGame();
            }
        }

        function saveScore(score){
            const names = ['小明','小红','玩家','客人','朋友','用户','访客','测试者','匿名','神秘人'];
            const name = names[Math.floor(Math.random() * names.length)];
            const existingScores = loadScores();
            existingScores.push({name, score, timestamp: Date.now()});
            existingScores.sort((a, b) => b.score - a.score || a.timestamp - b.timestamp);
            existingScores.splice(10);
            localStorage.setItem('tetrisScores', JSON.stringify(existingScores));
        }

        function loadScores(){
            return JSON.parse(localStorage.getItem('tetrisScores')) || [];
        }

        function initializeTetris(){
            tetrisLeft = canvas.width / 2 - (tetrisWidth * blockSize) / 2;
            tetrisTop = canvas.height / 2 - (tetrisHeight * blockSize) / 2;
            if(window.tetris) window.tetris.restart();
            else window.tetris = new Tetris();
        }

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function animate(){
            const now = Date.now();
            if(!window.tetris?.gameOver && now - lastMeteorTime > meteorInterval){
                generateMeteors();
                lastMeteorTime = now;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            meteors.forEach(m => {
                m.update();
                m.draw();
            });
            meteors = meteors.filter(m => m.active);

            papers.forEach(p => {
                p.update();
                p.draw();
            });

            if(window.tetris) window.tetris.draw();

            requestAnimationFrame(animate);
        }

        function generateMeteors(){
            for(let i = 0; i < 15; i++){
                meteors.push(new Meteor());
            }
        }

        document.addEventListener('keydown', (e) => {
            if(window.tetris?.gameOver){
                if(e.key === 'Enter') window.tetris.restart();
                return;
            }
            switch(e.key){
                case 'ArrowLeft': window.tetris.moveLeft(); break;
                case 'ArrowRight': window.tetris.moveRight(); break;
                case 'ArrowDown': window.tetris.moveDown(); break;
                case 'ArrowUp': window.tetris.rotate(); break;
            }
        });

        function resizeCanvas(){
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            papers.forEach(p => {
                p.x = Math.random() * canvas.width;
                p.y = Math.random() * canvas.height;
            });
            initializeTetris();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();

        lastMeteorTime = Date.now() - meteorInterval;
    </script>
</body>
</html>
